library ieee;
use ieee.std_logic_1164.all;

entity TB_work_reg is
--  Port ( );
end TB_work_reg;

architecture Behavioral of TB_work_reg is

	signal sim_done 	: std_logic := '0'; 		-- Signal fÃ¶r att avsluta simuleringen
	
	signal clk 			: std_logic := '0'; 		-- Klocksignal initieras till 0, det Ã¤r viktigt! Se rad 47!
	
	signal ena  		: std_logic := '0';
	signal n_rst		: std_logic := '0';
	signal D 			: std_logic_vector(7 downto 0); 
	signal Q 	 		: std_logic_vector(7 downto 0); 
	
	constant clk_period : time := 10 ns;			-- konstant signal fÃ¶r en klockperiod

	component work_reg is	-- Deklarerar en komponent
		port(
			clk   : in  std_logic;
			ena   : in  std_logic;
			n_rst : in  std_logic;
			D 	  : in  std_logic_vector(7 downto 0);
			Q 	  : out std_logic_vector(7 downto 0)
		);
	end component;

begin

	DUT_work_reg: work_reg	-- Instantierar en komponenent samt kopplar 
	port map(
		clk   => clk,
		ena   => ena,
		n_rst => n_rst,
		D 	  => D,
		Q 	  => Q 	 	
	);           
	
	clk_gen: process		-- Process fÃ¶r att generera en klocksignal
	begin
			
		if sim_done = '0' then			 	-- Kolla pÃ¥ rad 80. DÃ¤r sÃ¤tts sim_done till 1. Sedan skrivs en kommentar ut i
			wait for clk_period / 2;	 	-- terminalfÃ¶nstert, efter det kommer kommandot wait. DÃ¤r slutar simuleringen!		
			clk <= not clk;			-- Om klocksignalen inte hade varit initierad hade det uppstÃ¥t problem hÃ¤r
		else
			wait;
		end if;
	
	end process;


	DUT_stimuli: process	-- Process som skapar simuleringssignaler. 
	begin
	
	wait for clk_period;	
	
	n_rst <= '1';			
	ena	  <= '1';
	
	D <= "10100101";
	
	wait for 2*clk_period;
		
	D <= "10111101";
	
	wait for 2*clk_period;
		
	ena	  <= '0';
	D <= "10100101";
	
	wait for 2*clk_period;
		
	n_rst <= '0';
	
	wait for 2*clk_period;
		
	sim_done <= '1';
	report "Simulation done! :)" severity note;
	wait;
	end process;

end Behavioral;
